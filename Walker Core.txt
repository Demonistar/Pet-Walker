// Core v2.0 - Walker System Brain
// Handles initialization, channel calculation, LinkSetData storage, component rezzing

// ========== GLOBAL VARIABLES ==========
key owner;
integer channel = -1;
string pathName = "";
float speedOverride = 1.5; // Default walking speed
integer accessMode = 0; // 0=Owner, 1=Group, 2=Public, 3=Admin
list adminList = [];

integer setupChannel = 99;
integer listener = 0;
integer dialogChannel;

integer pathDataDetected = FALSE;
integer hudNeedsNC = FALSE;
integer deleteInitiated = FALSE;

string hudObject = "HUD";
string panelObject = "Panel";
string walkerObject = "Walker";

// Beacon linking state
integer linkingInProgress = FALSE;
integer expectedBeaconCount = 0;
list beaconsToLink = [];
integer currentLinkIndex = 0;

// ========== LINKSETDATA FUNCTIONS ==========
initLinkSetData() {
    // Calculate unique channel from UUID
    string uuid = llGetKey();
    integer hash = (integer)("0x" + llGetSubString(uuid, 0, 7));
    channel = -1000000 - llAbs(hash);
    
    // Store in LinkSetData
    llLinksetDataWrite("channel", (string)channel);
    llLinksetDataWrite("speed", (string)speedOverride);
    llLinksetDataWrite("accessMode", (string)accessMode);
    
    llOwnerSay("‚úÖ Channel calculated: /" + (string)channel);
}

loadLinkSetData() {
    string chanStr = llLinksetDataRead("channel");
    if (chanStr != "") channel = (integer)chanStr;
    
    string nameStr = llLinksetDataRead("pathName");
    if (nameStr != "") pathName = nameStr;
    
    string speedStr = llLinksetDataRead("speed");
    if (speedStr != "") speedOverride = (float)speedStr;
    
    string accessStr = llLinksetDataRead("accessMode");
    if (accessStr != "") accessMode = (integer)accessStr;
    
    string adminStr = llLinksetDataRead("adminList");
    if (adminStr != "") adminList = llCSV2List(adminStr);
}

saveLinkSetData() {
    llLinksetDataWrite("channel", (string)channel);
    llLinksetDataWrite("pathName", pathName);
    llLinksetDataWrite("speed", (string)speedOverride);
    llLinksetDataWrite("accessMode", (string)accessMode);
    if (llGetListLength(adminList) > 0) {
        llLinksetDataWrite("adminList", llList2CSV(adminList));
    }
}

// ========== HELPER FUNCTIONS ==========
integer isAdmin(key id) {
    if (id == owner) return TRUE;
    if (accessMode == 2) return TRUE;
    if (accessMode == 1 && llSameGroup(id)) return TRUE;
    if (accessMode == 3) {
        integer i;
        for (i = 0; i < llGetListLength(adminList); i++) {
            if (id == llList2Key(adminList, i)) return TRUE;
        }
    }
    return FALSE;
}

showHelp(key id) {
    string prefix = "/" + (string)channel + " ";
    llRegionSayTo(id, 0,
        "üìò Walker Core v2.0 Commands:\n" +
        prefix + "help ‚Äî Show this menu\n" +
        prefix + "set speed <0.5-5.0> ‚Äî Set walker speed\n" +
        prefix + "set access owner/group/public/admin ‚Äî Set permissions\n" +
        prefix + "rez hud ‚Äî Rez HUD for beacon placement\n" +
        prefix + "rez panel ‚Äî Rez control panel\n" +
        prefix + "rez walker ‚Äî Rez walker (after path setup)\n" +
        prefix + "show/hide ‚Äî Toggle beacon visibility\n" +
        prefix + "delete ‚Äî Remove entire system (exports path)"
    );
}

// ========== PATH EXPORT (for deletion) ==========
string formatFloat(float f, integer decimals) {
    string str = (string)f;
    integer dotPos = llSubStringIndex(str, ".");
    if (dotPos == -1) return str + ".0000";
    return llGetSubString(str, 0, dotPos + decimals);
}

string formatVector(vector v) {
    return formatFloat(v.x, 4) + ", " + formatFloat(v.y, 4) + ", " + formatFloat(v.z, 4);
}

list chunkString(string input, integer chunkSize) {
    list chunks = [];
    integer len = llStringLength(input);
    integer pos = 0;
    
    while (pos < len) {
        chunks += [llGetSubString(input, pos, pos + chunkSize - 1)];
        pos += chunkSize;
    }
    
    return chunks;
}

string exportPathData() {
    string output = "=====WALKER PATH DATA=====\n";
    output += "PathName: " + pathName + "\n";
    output += "Channel: " + (string)channel + "\n";
    output += "Speed: " + (string)speedOverride + "\n";
    output += "AccessMode: " + (string)accessMode + "\n";
    output += "Generated: " + llGetDate() + " " + llGetTimestamp() + "\n";
    
    if (accessMode == 3 && llGetListLength(adminList) > 0) {
        output += "AdminList: " + llList2CSV(adminList) + "\n";
    }
    
    output += "---WAYPOINTS---\n";
    
    // Scan all linked beacons
    list beaconData = [];
    integer i;
    for (i = 2; i <= llGetNumberOfPrims(); i++) {
        string linkName = llGetLinkName(i);
        
        if (llSubStringIndex(linkName, pathName + "_") == 0) {
            list parts = llParseString2List(linkName, ["_"], []);
            integer num = (integer)llList2String(parts, -1);
            
            vector pos = llList2Vector(
                llGetLinkPrimitiveParams(i, [PRIM_POSITION]), 0
            );
            
            beaconData += [num, pos];
        }
    }
    
    // Sort by beacon number
    beaconData = llListSort(beaconData, 2, TRUE);
    
    // Format: X, Y, Z, Rotation
    for (i = 0; i < llGetListLength(beaconData); i += 2) {
        vector pos = llList2Vector(beaconData, i + 1);
        
        // Calculate rotation to next point
        float rot = 0.0;
        if (i + 2 < llGetListLength(beaconData)) {
            vector nextPos = llList2Vector(beaconData, i + 3);
            rot = llAtan2(nextPos.y - pos.y, nextPos.x - pos.x);
        }
        
        output += formatVector(pos) + ", " + formatFloat(rot, 4) + "\n";
    }
    
    output += "---END---";
    
    return output;
}

// ========== BEACON LINKING FUNCTIONS ==========
startBeaconLinking() {
    linkingInProgress = TRUE;
    beaconsToLink = [];
    currentLinkIndex = 0;

    llOwnerSay("üîç Scanning for beacons with name pattern: " + pathName + "_*");

    // Use sensor to find beacons within 96m
    llSensor(pathName, "", SCRIPTED, 96.0, PI);
}

rebuildPathData() {
    llOwnerSay("üìä Collecting path data from linked beacons...");

    list beaconData = [];

    // Scan all child prims for beacons
    integer i;
    for (i = 2; i <= llGetNumberOfPrims(); i++) {
        string linkName = llGetLinkName(i);

        // Check if it's a beacon
        if (llSubStringIndex(linkName, pathName + "_") == 0) {
            // Extract number
            list parts = llParseString2List(linkName, ["_"], []);
            integer num = (integer)llList2String(parts, -1);

            // Get position
            list params = llGetLinkPrimitiveParams(i, [PRIM_POSITION]);
            vector pos = llList2Vector(params, 0);

            beaconData += [num, pos, i];
        }
    }

    // Sort by beacon number (stride=3)
    beaconData = llListSort(beaconData, 3, TRUE);

    integer waypointCount = llGetListLength(beaconData) / 3;
    llOwnerSay("üìç Found " + (string)waypointCount + " waypoints");

    if (waypointCount == 0) {
        llOwnerSay("‚ö†Ô∏è No beacon waypoints found!");
        return;
    }

    // Build waypoint list with rotations
    list waypoints = [];
    for (i = 0; i < llGetListLength(beaconData); i += 3) {
        vector pos = llList2Vector(beaconData, i + 1);

        // Calculate rotation to next waypoint
        float rot = 0.0;
        if (i + 3 < llGetListLength(beaconData)) {
            vector nextPos = llList2Vector(beaconData, i + 4);
            rot = llAtan2(nextPos.y - pos.y, nextPos.x - pos.x);
        } else {
            // Last waypoint - rotate towards first for loop
            vector firstPos = llList2Vector(beaconData, 1);
            rot = llAtan2(firstPos.y - pos.y, firstPos.x - pos.x);
        }

        waypoints += [pos, rot];
    }

    // Format as string for LinkSetData: x,y,z,rot|x,y,z,rot|...
    string pathData = "";
    for (i = 0; i < llGetListLength(waypoints); i += 2) {
        vector pos = llList2Vector(waypoints, i);
        float rot = llList2Float(waypoints, i + 1);

        if (i > 0) pathData += "|";
        pathData += (string)pos.x + "," + (string)pos.y + "," + (string)pos.z + "," + (string)rot;
    }

    // Save to LinkSetData
    llLinksetDataWrite("pathData", pathData);

    // Broadcast to Walker
    llRegionSay(channel, "pathUpdate:" + pathData);

    llOwnerSay("‚úÖ Path collected: " + (string)(llGetListLength(waypoints)/2) + " waypoints");
    llOwnerSay("üìç Walker can now be rezzed with: /" + (string)channel + " rez walker");
}

// ========== DEFAULT STATE ==========
default {
    state_entry() {
        owner = llGetOwner();

        // Check if LinkSetData exists (fresh rez vs re-rez)
        string existingName = llLinksetDataRead("pathName");

        if (existingName == "") {
            // Brand new Core - first time setup
            llOwnerSay("üõ†Ô∏è Initializing Walker Core v2.0...");
            initLinkSetData();

            // Check for PathData notecard
            if (llGetInventoryType("PathData") == INVENTORY_NOTECARD) {
                pathDataDetected = TRUE;
                llOwnerSay("üìã PathData notecard detected!");
            }

            // Ask for path name
            listener = llListen(setupChannel, "", owner, "");
            llTextBox(owner,
                "üìù Enter a name for this walker path:\n(Example: AquariumPath, ForestWalk, etc.)",
                setupChannel
            );
        } else {
            // Existing Core being re-rezzed - load saved data
            loadLinkSetData();
            llOwnerSay("üîÑ Core loaded: Channel /" + (string)channel + ", Path: " + pathName);

            // Check for PathData notecard
            if (llGetInventoryType("PathData") == INVENTORY_NOTECARD) {
                pathDataDetected = TRUE;
                llOwnerSay("üìã PathData notecard detected!");
            }

            // Start listening on main channel
            listener = llListen(channel, "", NULL_KEY, "");
            llOwnerSay("‚úÖ Ready! Type /" + (string)channel + " help for commands.");
        }
    }
    
    on_rez(integer param) {
        llResetScript();
    }
    
    listen(integer chan, string name, key id, string msg) {
        // Path name setup
        if (chan == setupChannel && pathName == "" && id == owner) {
            pathName = msg;
            llLinksetDataWrite("pathName", pathName);
            
            llOwnerSay("‚úÖ Path name set to: " + pathName);
            
            // Start listening on main channel
            if (listener) llListenRemove(listener);
            listener = llListen(channel, "", NULL_KEY, "");
            
            llOwnerSay("‚úÖ Ready! Type /" + (string)channel + " help for commands.");
            return;
        }
        
        // Main commands
        if (chan != channel) return;
        if (!isAdmin(id)) {
            llRegionSayTo(id, 0, "‚õî You don't have permission to control this system.");
            return;
        }
        
        string lower = llToLower(msg);
        
        if (lower == "help") {
            showHelp(id);
        }
        
        else if (llSubStringIndex(lower, "set speed ") == 0) {
            float spd = (float)llGetSubString(lower, 10, -1);
            if (spd < 0.5 || spd > 5.0) {
                llRegionSayTo(id, 0, "‚ö†Ô∏è Speed must be between 0.5 and 5.0 m/s");
            } else {
                speedOverride = spd;
                saveLinkSetData();
                llRegionSay(channel, "speedUpdate:" + (string)speedOverride);
                llRegionSayTo(id, 0, "‚úÖ Speed set to " + (string)speedOverride + " m/s");
            }
        }
        
        else if (llSubStringIndex(lower, "set access ") == 0) {
            string mode = llGetSubString(lower, 11, -1);
            if (mode == "owner") accessMode = 0;
            else if (mode == "group") accessMode = 1;
            else if (mode == "public") accessMode = 2;
            else if (mode == "admin") accessMode = 3;
            else {
                llRegionSayTo(id, 0, "‚ö†Ô∏è Invalid mode. Use: owner, group, public, or admin");
                return;
            }
            saveLinkSetData();
            llRegionSayTo(id, 0, "üîí Access mode set to: " + mode);
        }
        
        else if (lower == "rez hud") {
            if (id != owner) {
                llRegionSayTo(id, 0, "‚õî Only the owner can rez the HUD.");
                return;
            }
            
            vector rezPos = llGetRootPosition() + <0, 0, 0.5>;
            
            // Check if PathData exists
            if (llGetInventoryType("PathData") == INVENTORY_NOTECARD) {
                llOwnerSay("üìã PathData detected - will transfer to HUD for auto-restore...");
                hudNeedsNC = TRUE;
            }
            
            llRezObject(hudObject, rezPos, ZERO_VECTOR, ZERO_ROTATION, 0);
        }
        
        else if (lower == "rez panel") {
            vector rezPos = llGetRootPosition() + <0, 1, 0.5>;
            llRezObject(panelObject, rezPos, ZERO_VECTOR, ZERO_ROTATION, 0);
        }
        
        else if (lower == "rez walker") {
            vector rezPos = llGetRootPosition() + <1, 0, 0>;
            llRezObject(walkerObject, rezPos, ZERO_VECTOR, ZERO_ROTATION, 0);
        }

        else if (llSubStringIndex(msg, "LINK_BEACONS:") == 0) {
            expectedBeaconCount = (integer)llGetSubString(msg, 13, -1);
            llOwnerSay("üîó Starting beacon linking process for " + (string)expectedBeaconCount + " beacons...");

            // Request permissions if not already granted
            integer perms = llGetPermissions();
            if (!(perms & PERMISSION_CHANGE_LINKS)) {
                llOwnerSay("üìã Requesting linking permissions...");
                llRequestPermissions(owner, PERMISSION_CHANGE_LINKS);
            } else {
                // Start linking immediately
                startBeaconLinking();
            }
        }

        else if (lower == "show") {
            llSetLinkAlpha(LINK_ALL_CHILDREN, 1.0, ALL_SIDES);
            llRegionSayTo(id, 0, "üëÅÔ∏è Beacons visible");
        }
        
        else if (lower == "hide") {
            llSetLinkAlpha(LINK_ALL_CHILDREN, 0.0, ALL_SIDES);
            llRegionSayTo(id, 0, "ü´• Beacons hidden");
        }
        
        else if (lower == "reset") {
            if (id != owner) return;
            llLinksetDataReset();
            llOwnerSay("üîÑ LinkSetData cleared - resetting...");
            llResetScript();
        }
        
        else if (llSubStringIndex(msg, "systemDelete:") == 0) {
            key requester = (key)llGetSubString(msg, 13, -1);
            
            if (requester != owner) return;
            
            // Export path data
            llRegionSayTo(requester, 0, "------COPY TO NOTECARD FOR FUTURE RESTORES------");
            
            string export = exportPathData();
            list chunks = chunkString(export, 900);
            integer i;
            for (i = 0; i < llGetListLength(chunks); i++) {
                llRegionSayTo(requester, 0, llList2String(chunks, i));
                llSleep(0.1);
            }
            
            llRegionSayTo(requester, 0, "------END PATH DATA------");
            llRegionSayTo(requester, 0, "üíæ Save the above to a notecard named 'PathData' for restoration.");
            
            // Broadcast delete to components
            llRegionSay(channel, "componentDelete");
            
            // Wait then die
            llSleep(2.0);
            llRegionSayTo(requester, 0, "üóëÔ∏è Core (and all " + (string)(llGetNumberOfPrims() - 1) + " beacons) deleting now...");
            
            llDie();
        }
    }
    
    object_rez(key id) {
        string name = llKey2Name(id);

        if (name == hudObject) {
            // Send config to HUD
            string hudData = "hudConfig:channel=" + (string)channel + ";pathName=" + pathName;
            llRegionSayTo(id, 0, hudData);

            // Transfer PathData if exists
            if (hudNeedsNC && llGetInventoryType("PathData") == INVENTORY_NOTECARD) {
                llGiveInventory(id, "PathData");
                llOwnerSay("‚úÖ PathData notecard transferred to HUD");
                hudNeedsNC = FALSE;
            }
        }

        else if (name == panelObject) {
            // Send config to Panel
            string panelData = "panelConfig:channel=" + (string)channel + ";pathName=" + pathName + ";access=" + (string)accessMode;
            llRegionSayTo(id, 0, panelData);
        }

        else if (name == walkerObject) {
            // Send config to Walker
            string walkerData = "walkerConfig:channel=" + (string)channel + ";pathName=" + pathName + ";speed=" + (string)speedOverride;
            llRegionSayTo(id, 0, walkerData);
        }
    }

    run_time_permissions(integer perm) {
        if (perm & PERMISSION_CHANGE_LINKS) {
            llOwnerSay("‚úÖ Linking permissions granted");
            startBeaconLinking();
        }
    }

    sensor(integer num) {
        llOwnerSay("üì° Found " + (string)num + " objects, filtering for beacons...");

        // Collect all beacons that match our path name pattern
        integer i;
        for (i = 0; i < num; i++) {
            string objName = llDetectedName(i);
            key objKey = llDetectedKey(i);

            // Check if this is one of our beacons
            if (llSubStringIndex(objName, pathName + "_") == 0) {
                // Extract beacon number
                list parts = llParseString2List(objName, ["_"], []);
                integer beaconNum = (integer)llList2String(parts, -1);

                // Add to list: [number, key, name]
                beaconsToLink += [beaconNum, objKey, objName];
            }
        }

        // Sort by beacon number (stride 3)
        beaconsToLink = llListSort(beaconsToLink, 3, TRUE);

        integer foundCount = llGetListLength(beaconsToLink) / 3;
        llOwnerSay("‚úÖ Found " + (string)foundCount + " beacons to link");

        if (foundCount == 0) {
            llOwnerSay("‚ö†Ô∏è No beacons found! Make sure they're named correctly.");
            linkingInProgress = FALSE;
            return;
        }

        // Start linking process with timer
        currentLinkIndex = 0;
        llSetTimerEvent(0.5);
    }

    no_sensor() {
        llOwnerSay("‚ö†Ô∏è No objects found in range. Make sure beacons are within 96m!");
        linkingInProgress = FALSE;
    }

    timer() {
        if (linkingInProgress && llGetListLength(beaconsToLink) > 0) {
            // Link one beacon at a time
            if (currentLinkIndex < llGetListLength(beaconsToLink)) {
                integer beaconNum = llList2Integer(beaconsToLink, currentLinkIndex);
                key beaconKey = llList2Key(beaconsToLink, currentLinkIndex + 1);
                string beaconName = llList2String(beaconsToLink, currentLinkIndex + 2);

                llOwnerSay("üîó Linking beacon " + (string)beaconNum + ": " + beaconName);
                llCreateLink(beaconKey, TRUE);

                currentLinkIndex += 3;
                llSetTimerEvent(0.5); // Wait before next link
            } else {
                // All beacons linked!
                llSetTimerEvent(0.0);
                linkingInProgress = FALSE;
                llOwnerSay("üéâ All " + (string)(llGetListLength(beaconsToLink) / 3) + " beacons linked!");

                // Wait for beacon scripts to self-delete, then collect path data
                llOwnerSay("‚è≥ Waiting for beacon scripts to clean up...");
                llSetTimerEvent(2.5);
            }
        } else if (!linkingInProgress && llGetListLength(beaconsToLink) > 0) {
            // Cleanup after linking - collect path data
            beaconsToLink = [];
            llSetTimerEvent(0.0);
            rebuildPathData();
        } else {
            llSetTimerEvent(0.0);
        }
    }

    changed(integer change) {
        if (change & CHANGED_OWNER) llResetScript();

        if (change & CHANGED_LINK) {
            // Link changed - beacons added or removed
            if (!linkingInProgress) {
                llOwnerSay("üîó Link change detected");
            }
        }
    }
}
